#' Run mixed-effects model for two-factor within-subject design using (\code{\link[lme4]{lmer}})
#' 
#' Runs either a random-intercepts only model, a maximal
#' random-effects model (random intercepts and slopes for both subject and item for
#' within-item designs; random intercepts for both subject and item, but only random
#' slopes for subject for between-item designs), or a no-covariance random-effect
#' model (same as maximal model but without covariances between random intercepts
#' and slopes). This function is especially tailored for use in simulations 
#' using \code{\link[simgen]{mcRun}}.
#' NB: this function is for two-factor within-subject design with one
#' variable representing condition and another variable representing measurement time.
#' 
#' \code{fitlmerAB} will attempt to fit the model specified by the user. 
#' \code{fitlmerAB} calculates p-values by
#' (1) using the t-statistic as an approximation for z-distribution (only when ncond = 2); 
#' (2) likelihood ratio tests, (3) conditional F-tests with Kenward-Roger correction 
#' of degrees-of-freedom through \code{\link[pbkrtest]{KRmodcomp}}, 
#' (4) parametric bootstrapping using \code{\link[pbkrtest]{PBmodcomp}}.
#' 
#' @param mcr.data A dataframe formatted as generated by \code{\link{generate_data}}.
#' @param ri.only Whether the random effects specification is to be
#' random-intercepts only (TRUE) or maximal random-effects (FALSE).
#' @param wsbi Whether the design is between-items (TRUE) or within-items
#' (FALSE).
#' @param NoCovar If TRUE, model to be fitted will be a no-covariance model.
#' If FALSE, model to be fitted will be the maximal model.
#' @param ncond Number of levels of the condition variable
#' @param krmodcomp If TRUE calculates F-statistics with Kenward-Roger correction using \code{\link[pbkrtest]{KRmodcomp}}
#' @param pbmodcomp If TRUE calculates parametrically bootstrapped LRT effects using \code{\link[pbkrtest]{PBmodcomp}}
#' @return A vector with elements:
#' If LRT = true:
#' \item{convmain}{Code signifying convergence of main model
#' for use in LRTs and bootstrapping (REML = FALSE): 
#' (0): model converged without issue
#' (1) : model converged after upping the iterations to 250,000
#' (2) : model did not converge after upping the iterations}
#' \item{convCond}{Code signifying convergence of LRT model without Condition (REML = FALSE): 
#' (0): model converged without issue
#' (1) : model converged after upping the iterations to 250,000
#' (2) : model did not converge after upping the iterations}
#' \item{convMeas}{Code signifying convergence of LRT model without Measurement Time: (REML = FALSE) 
#' (0): model converged without issue
#' (1) : model converged after upping the iterations to 250,000
#' (2) : model did not converge after upping the iterations}
#' \item{convInt}{Code signifying convergence of LRT model without Interaction (REML = FALSE): 
#' (0): model converged without issue
#' (1) : model converged after upping the iterations to 250,000
#' (2) : model did not converge after upping the iterations}
#' \item{t.Cond}{t-statistic for the condition effect}
#' \item{pt.Cond}{p-value for the t-statistic of condition (normal distribution) }
#' \item{chi.Cond}{chi-square statistic for the likelihood ratio test (1 df) 
#' for the condition effect }
#' \item{pchi.Cond}{p-value for the chi-square statistic for condition effect }
#' \item{t.Meas}{t-statistic for the measurement effect}
#' \item{pt.Meas}{p-value for the t-statistic of measurement (normal distribution)}
#' \item{chi.Meas}{chi-square statistic for the likelihood ratio test (1 df) for the measurement effect}
#' \item{pchi.Meas}{p-value for the chi-square statistic for measurement effect}
#' \item{t.Int}{t-statistic for the interaction effect }
#' \item{pt.Int}{p-value for the t-statistic of interaction (normal distribution) }
#' \item{chi.Int}{chi-square statistic for the likelihood ratio test (1 df) 
#' for the interaction effect }
#' \item{pchi.Int}{p-value for the chi-square statistic for interaction effect }
#' 
#' If krmodcomp = TRUE:
#' \item{convmain.kr}{Code signifying convergence of main model
#' for use with krmodcomp (REML=TRUE): 
#' (0): model converged without issue
#' (1) : model converged after upping the iterations to 250,000
#' (2) : model did not converge after upping the iterations}
#' \item{convCond.kr}{Code signifying convergence of krmodcomp model without Condition (REML=TRUE): 
#' (0): model converged without issue
#' (1) : model converged after upping the iterations to 250,000
#' (2) : model did not converge after upping the iterations}
#' \item{convMeas.kr}{Code signifying convergence of krmodcomp model without Measurement Time (REML=TRUE): 
#' (0): model converged without issue
#' (1) : model converged after upping the iterations to 250,000
#' (2) : model did not converge after upping the iterations}
#' \item{convInt.kr}{Code signifying convergence of krmodcomp model without Interaction (REML=TRUE): 
#' (0): model converged without issue
#' (1) : model converged after upping the iterations to 250,000
#' (2) : model did not converge after upping the iterations}
#' \item{f.Cond}{F-statistic with Kenward-Roger correction for condition effect }
#' \item{pf.Cond}{p-value for the F-statistic with Kenward-Roger correction for 
#' condition effect}
#' \item{f.Meas}{F-statistic with Kenward-Roger correction for measurement effect}
#' \item{pf.Meas}{p-value for the F-statistic with Kenward-Roger correction for 
#' measurement effect}
#' \item{f.Int}{F-statistic with Kenward-Roger correction for interaction effect}
#' \item{pf.Int}{p-value for the F-statistic with Kenward-Roger correction for 
#' interaction effect}
#' 
#' If pbmodcomp = TRUE:
#' \item{PBtest.Cond}{p-value of Condition determined as the fraction of simulated LRT-values that are larger
#' or equal to the observed LRT value}
#' \item{Bartlett.Cond}{p-value of Condition determined from the mean of simulated LRT-values}
#' \item{Gamma.Cond}{p-value of Condition determined from a gamma distribution with mean and variance
#' determined as the sample mean and variance of simulated LRT-values}
#' \item{PBtest.Meas}{p-value of Measurement Time determined as the fraction of simulated LRT-values that are larger
#' or equal to the observed LRT value}
#' \item{Bartlett.Meas}{p-value of Measurement Time determined from the mean of simulated LRT-values}
#' \item{Gamma.Meas}{p-value of Measurement Time determined from a gamma distribution with mean and variance
#' determined as the sample mean and variance of simulated LRT-values}
#' \item{PBtest.Int}{p-value of Interaction determined as the fraction of simulated LRT-values that are larger
#' or equal to the observed LRT value}
#' \item{Bartlett.Int}{p-value of Interaction determined from the mean of simulated LRT-values}
#' \item{Gamma.Int}{p-value of Interaction determined from a gamma distribution with mean and variance
#' determined as the sample mean and variance of simulated LRT-values}
#' @seealso \code{\link{generate_data}}, \code{\link[funfact]{sim_norm}}, \code{\link[simgen]{mcRun}}
#' @examples
#'
#' #Design with 4 condition levels
#' design_args <- list(ivs = c(Cond = 4), n_item = 24, n_rep=2)
#' pop_params <- gen_pop(design_args, 24)
#' xd <- sim_norm(design_args, 12, pop_params)
#' colnames(xd)[colnames(xd)=="n_rep"] <- 'Meas'
#' colnames(xd)[colnames(xd)=="Y"] <- 'Resp'
#' colnames(xd)[colnames(xd)=="subj_id"] <- 'SubjID'
#' colnames(xd)[colnames(xd)=="item_id"] <- 'ItemID'
#' xd <- with_dev_pred(xd, c("Cond", "Meas")) 
#' 
#' # Maximal model for within-item design
#' fitlmerAB(xd, ncond=4, NoCovar=FALSE)
#' 
#' # Maximal model for between-subject design
#' fitlmerAB(xd, ncond=4, wsbi=TRUE, NoCovar=FALSE)
#' 
#' #Random intercept only design
#' fitlmerAB(xd, ncond=4, ri.only=TRUE)
#' 
#' #Maximal within-item model with 4 condition levels for use in mcRun to run 1000 simulations
#' my_des <- list(ivs = c(Cond = 4), n_item = 24, n_rep = 2)
#' pops <- replicate(1000, gen_pop(my_des, 24), simplify = FALSE)
#' 
#' result <- mcRun("fitlmerAB",
#' mcr.fnArgs = list(ncond=4, NoCovar=FALSE)
#' mcr.datFn = "generate_data",
#' mcr.constant = list(design_args = my_des, n_subj = 24),
#' mcr.varying = pops) 
#' 
#' @export fitlmerAB

fitlmerAB <- function(mcr.data, ri.only=FALSE, wsbi=FALSE, NoCovar = FALSE, ncond=2, LRT = TRUE, krmodcomp = FALSE, pbmodcomp = FALSE) {
  xd <- mcr.data
  listoflevels <- c(paste0("CondCond", 2:(ncond))) #Character list of contrast names of Condition

  convmain <- 0
    
                                        # convergence codes:
                                        # 0 : models converged without issue
                                        # 1 : maximal model converged after upping the iterations
                                        # 2 : model did not converge after upping the iterations
                                        
  library(lme4, quietly=TRUE)
  if (ri.only) { #If only random intercept, write a formula with random intercept for SubjID and ItemID
    mf <- as.formula(paste0("Resp ~ (", paste(listoflevels, collapse="+"), ") * Measr2 + (1 | SubjID) + (1 | ItemID)"))
  } else {
    if (NoCovar){
      #Write formula for no-covariance model, is wsbi = TRUE (condition is between items), no random slopes for ItemID
      if (!wsbi) {
        mf <- as.formula(paste0("Resp ~ (", paste(listoflevels, collapse="+"), ") * Measr2 + (0 + (", paste(listoflevels, collapse="+"), ") * Measr2 | SubjID) + (1 | SubjID) + (0 + (", paste(listoflevels, collapse="+"), ") * Measr2| ItemID) + (1 | ItemID)"))
      } else {
        mf <- as.formula(paste0("Resp ~ (", paste(listoflevels, collapse="+"), ") * Measr2 + (0 + (", paste(listoflevels, collapse="+"), ")* Measr2 | SubjID) + (1 | SubjID) + (1 | ItemID)"))
      }
    } else {
      #Write formula for maximal model, is wsbi = TRUE (condition is between items), no random slopes for ItemID
      if (!wsbi) {
        mf <- as.formula(paste0("Resp ~ (", paste(listoflevels, collapse="+"), ") * Measr2 + (1 + (", paste(listoflevels, collapse="+"), ") * Measr2 | SubjID) + (1 + (", paste(listoflevels, collapse="+"), ") * Measr2| ItemID)"))
      } else {
        mf <- as.formula(paste0("Resp ~ (", paste(listoflevels, collapse="+"), ") * Measr2 + (1 + (", paste(listoflevels, collapse="+"), ")* Measr2 | SubjID) + (1 | ItemID)"))
      }
    }
  }
  
  #Formula without Condition
  mf2 <- mf
  for (i in listoflevels) {
    mf2 <- as.formula(paste(deparse(mf2,width.cutoff=500), "-", i))
  }
  
  #Formula without Meas
  mf3 <- as.formula(paste(deparse(mf,width.cutoff=500),"-Measr2"))
  
  #Formula without interaction
  mf4 <- mf
  for (i in listoflevels) {
    mf4 <- as.formula(paste(deparse(mf4,width.cutoff=500), "-", i, ":Measr2"))
  }
  
  if (LRT){
    #Fit model, catch warnings and errors
    xd.lmer <- tryCatch(lmer(mf,
                             data=xd, na.action=na.omit, REML=FALSE),
                        warning = function(w) {return (NULL)},
                        error = function(e) {return (NULL)})
    
    if (is.null(xd.lmer)) { #If main model doesn't converge, up iterations to 250,000
      convmain <- 1
      xd.lmer <- tryCatch(lmer(mf,
                               data=xd, na.action=na.omit, REML=FALSE, control=lmerControl(optCtrl=list(maxfun=250000))),
                          warning = function(w) {return (NULL)},
                          error = function(e) {return (NULL)})
    } else {}
    
    if (is.null(xd.lmer)) { #If main model doesn't converge after upping iterations, update convergence and stop function
      convmain <- 2
      v1 <- c(convMain = convmain, convCond = NA, t.Cond=NA, pt.Cond=NA, chi.Cond=NA, pchi.Cond=NA,
              convMeas = NA, t.Meas=NA, pt.Meas=NA, chi.Meas=NA, pchi.Meas=NA,
              convInt = NA, t.Int=NA, chi.Int=NA, pt.Int=NA, pchi.Int=NA)
      return(v1)
    } else {
      
      #Calculate t's and p's
      if (ncond == 2){
        ts.Cond.tval <- abs(fixef(xd.lmer)[2]/sqrt(Matrix:::diag(vcov(xd.lmer))[2]))
        ts.Meas.tval <- abs(fixef(xd.lmer)[3]/sqrt(Matrix:::diag(vcov(xd.lmer))[3]))
        ts.Int.tval <- abs(fixef(xd.lmer)[4]/sqrt(Matrix:::diag(vcov(xd.lmer))[4]))
        p.Cond.t <- 2*(1-pnorm(ts.Cond.tval))
        p.Meas.t <- 2*(1-pnorm(ts.Meas.tval))
        p.Int.t <- 2*(1-pnorm(ts.Int.tval))
      } else {
        ts.Cond.tval <- NA
        ts.Meas.tval <- NA
        ts.Int.tval <- NA
        p.Cond.t <- NA
        p.Meas.t <- NA
        p.Int.t <- NA
      }
        
      #Run model without Condition to test significance of Condition with LRT
      convcond <- 0
      xd.lmer.2 <- tryCatch(lmer(mf2,
                                 data=xd, na.action=na.omit, REML=FALSE),
                            warning=function(w) {return(NULL)},
                            error=function(e) {return(NULL)})
      if (is.null(xd.lmer.2)) { #If no convergence, up iterations
        convcond <- 1
        xd.lmer.2 <- tryCatch(lmer(mf2,
                                   data=xd, na.action=na.omit, REML=FALSE, control=lmerControl(optCtrl=list(maxfun=250000))),
                              warning=function(w) {return(NULL)},
                              error=function(e) {return(NULL)})
        if (is.null(xd.lmer.2)) { #If no convergence after upped iterations, stop LRT
          condvcond <- 2
          ts.Cond.chi <- NA
          p.Cond.chi <- NA
        } else {
          ts.Cond.chi <- deviance(xd.lmer.2)-deviance(xd.lmer)
          p.Cond.chi <- pchisq(abs(ts.Cond.chi), 1, lower.tail=F)
        }
      } else {
        ts.Cond.chi <- deviance(xd.lmer.2)-deviance(xd.lmer)
        p.Cond.chi <- pchisq(abs(ts.Cond.chi), 1, lower.tail=F)
      }
      
      #Run model without Measurement to test significance of Measurement with LRT
      convmeas <- 0
      xd.lmer.3 <- tryCatch(lmer(mf3,
                                 data=xd, na.action=na.omit, REML=FALSE),
                            warning=function(w) {return(NULL)},
                            error=function(e) {return(NULL)})
      if (is.null(xd.lmer.3)) { #If no convergence, up iterations
        convmeas <- 1
        xd.lmer.3 <- tryCatch(lmer(mf3,
                                   data=xd, na.action=na.omit, REML=FALSE, control=lmerControl(optCtrl=list(maxfun=250000))),
                              warning=function(w) {return(NULL)},
                              error=function(e) {return(NULL)})
        if (is.null(xd.lmer.3)) { #If no convergence after upped iterations, stop LRT
          convmeas <- 2
          ts.Meas.chi <- NA
          p.Meas.chi <- NA
        } else {
          ts.Meas.chi <- deviance(xd.lmer.3)-deviance(xd.lmer)
          p.Meas.chi <- pchisq(abs(ts.Meas.chi), 1, lower.tail=F)
        }
      } else {
        ts.Meas.chi <- deviance(xd.lmer.3)-deviance(xd.lmer)
        p.Meas.chi <- pchisq(abs(ts.Meas.chi), 1, lower.tail=F)
      }
        
      #Run model without interaction to test significance of interaction with LRT
      convint <- 0
      xd.lmer.4 <- tryCatch(lmer(mf4,
                                 data=xd, na.action=na.omit, REML=FALSE),
                            warning=function(w) {return(NULL)},
                            error=function(e) {return(NULL)})
      if (is.null(xd.lmer.4)) { #If no convergence, up iterations
        convint <- 1
        xd.lmer.4 <- tryCatch(lmer(mf4,
                                   data=xd, na.action=na.omit, REML=FALSE, control=lmerControl(optCtrl=list(maxfun=250000))),
                              warning=function(w) {return(NULL)},
                              error=function(e) {return(NULL)})
        if (is.null(xd.lmer.4)) { #If no convergence after upped iterations, stop LRT
          convint <- 2
          ts.Int.chi <- NA
          p.Int.chi <- NA
        } else {
          ts.Int.chi <- deviance(xd.lmer.4)-deviance(xd.lmer)
          p.Int.chi <- pchisq(abs(ts.Int.chi), 1, lower.tail=F)
        }
      } else {
        ts.Int.chi <- deviance(xd.lmer.4)-deviance(xd.lmer)
        p.Int.chi <- pchisq(abs(ts.Int.chi), 1, lower.tail=F)
      }
      
      v1 <- c(convMain = convmain, convCond = convcond, t.Cond=ts.Cond.tval, pt.Cond=p.Cond.t, chi.Cond=ts.Cond.chi, pchi.Cond=p.Cond.chi,
                  convMeas = convmeas, t.Meas=ts.Meas.tval, pt.Meas=p.Meas.t, chi.Meas=ts.Meas.chi, pchi.Meas=p.Meas.chi,
                  convInt = convint, t.Int=ts.Int.tval, chi.Int=ts.Int.chi, pt.Int=p.Int.t, pchi.Int=p.Int.chi)
    }
  } else {}
  

  if (krmodcomp) {
    #krmodcomp f-tests. Needs models that are fitted with REML instead of ML.      
    library(pbkrtest, quietly=TRUE)
      
    #Run main model
    convmain.kr <- 0
    xd.lmer.kr <- tryCatch(lmer(mf,
                                data=xd, na.action=na.omit, REML=TRUE),
                           warning = function(w) {return (NULL)},
                           error = function(e) {return (NULL)})
    if (is.null(xd.lmer.kr)) { #If main model doesn't converge, up iterations to 250,000
      convmain.kr <- 1
      xd.lmer.kr <- tryCatch(lmer(mf,
                                 data=xd, na.action=na.omit, REML=TRUE, control=lmerControl(optCtrl=list(maxfun=250000))),
                            warning = function(w) {return (NULL)},
                            error = function(e) {return (NULL)})
      } else {}
      
      if (is.null(xd.lmer.kr)) { #If main model doesn't converge after upping iterations, update convergence and stop function
        convmain.kr <- 2
        v1 <- c(convMain.kr = convmain.kr, convCond.kr = NA, f.Cond=NA, pf.Cond=NA,
                convMeas.kr = NA, f.Meas=NA, pf.Meas=NA,
                convInt.kr = NA, f.Int=NA, pf.Int=NA)
        return(v1)
      } else {
                
        #Run model without Condition
        convcond.kr <- 0
        xd.lmer.kr.2 <- tryCatch(lmer(mf2,
                                   data=xd, na.action=na.omit, REML=TRUE),
                              warning=function(w) {return(NULL)},
                              error=function(e) {return(NULL)})
        if (is.null(xd.lmer.kr.2)) { #If no convergence, up iterations
          convcond.kr <- 1
          xd.lmer.kr.2 <- tryCatch(lmer(mf2,
                                     data=xd, na.action=na.omit, REML=TRUE, control=lmerControl(optCtrl=list(maxfun=250000))),
                                warning=function(w) {return(NULL)},
                                error=function(e) {return(NULL)})
          if (is.null(xd.lmer.2)) { #If no convergence after upped iterations, stop LRT
            condvcond.kr <- 2
            f.Cond <- NA
            pf.Cond <- NA
          } else {
            ftest.Cond <- KRmodcomp(xd.lmer.kr, xd.lmer.kr.2)
            f.Cond <- getKR(ftest.Cond, "Fstat")
            pf.Cond <- getKR(ftest.Cond, "p.value")
          }
        } else {
          ftest.Cond <- KRmodcomp(xd.lmer.kr, xd.lmer.kr.2)
          f.Cond <- getKR(ftest.Cond, "Fstat")
          pf.Cond <- getKR(ftest.Cond, "p.value")
        }
        
        #Run model without Measurement
        convmeas.kr <- 0
        xd.lmer.kr.3 <- tryCatch(lmer(mf3,
                                   data=xd, na.action=na.omit, REML=TRUE),
                              warning=function(w) {return(NULL)},
                              error=function(e) {return(NULL)})
        if (is.null(xd.lmer.kr.3)) { #If no convergence, up iterations
          convmeas.kr <- 1
          xd.lmer.kr.3 <- tryCatch(lmer(mf3,
                                     data=xd, na.action=na.omit, REML=TRUE, control=lmerControl(optCtrl=list(maxfun=250000))),
                                warning=function(w) {return(NULL)},
                                error=function(e) {return(NULL)})
          if (is.null(xd.lmer.kr.3)) { #If no convergence after upped iterations, stop LRT
            convmeas.kr <- 2
            f.Meas <- NA
            pf.Meas <- NA
          } else {
            ftest.Meas <- KRmodcomp(xd.lmer.kr, xd.lmer.kr.3)
            f.Meas <- getKR(ftest.Meas, "Fstat")
            pf.Meas <- getKR(ftest.Meas, "p.value")
          }
        } else {
          ftest.Meas <- KRmodcomp(xd.lmer.kr, xd.lmer.kr.3)
          f.Meas <- getKR(ftest.Meas, "Fstat")
          pf.Meas <- getKR(ftest.Meas, "p.value")
        }
        
        #Run model without interaction to test significance of interaction with LRT
        convint.kr <- 0
        xd.lmer.kr.4 <- tryCatch(lmer(mf4,
                                   data=xd, na.action=na.omit, REML=TRUE),
                              warning=function(w) {return(NULL)},
                              error=function(e) {return(NULL)})
        if (is.null(xd.lmer.kr.4)) { #If no convergence, up iterations
          convint.kr <- 1
          xd.lmer.kr.4 <- tryCatch(lmer(mf4,
                                     data=xd, na.action=na.omit, REML=TRUE, control=lmerControl(optCtrl=list(maxfun=250000))),
                                warning=function(w) {return(NULL)},
                                error=function(e) {return(NULL)})
          if (is.null(xd.lmer.kr.4)) { #If no convergence after upped iterations, stop LRT
            convint.kr <- 2
            f.Int <- NA
            pf.Int <- NA
          } else {
            ftest.Int <- KRmodcomp(xd.lmer.kr, xd.lmer.kr.4)
            f.Int <- getKR(ftest.Int, "Fstat")
            pf.Int <- getKR(ftest.Int, "p.value")
          }
        } else {
          ftest.Int <- KRmodcomp(xd.lmer.kr, xd.lmer.kr.4)
          f.Int <- getKR(ftest.Int, "Fstat")
          pf.Int <- getKR(ftest.Int, "p.value")
        }
                
        if (LRT) {
          v1 <- c(v1, convmain.kr=convmain.kr, convCond.kr=convcond.kr, convMeas.kr=convmeas.kr, convInt.kr=convint.kr, f.Cond=f.Cond, pf.Cond=pf.Cond, f.Meas=f.Meas, pf.Meas=pf.Meas, f.Int=f.Int, pf.Int=pf.Int)
        } else {
          v1 <- c(convmain.kr=convmain.kr, convCond.kr=convcond.kr, convMeas.kr=convmeas.kr, convInt.kr=convint.kr, f.Cond=f.Cond, pf.Cond=pf.Cond, f.Meas=f.Meas, pf.Meas=pf.Meas, f.Int=f.Int, pf.Int=pf.Int)
        }
      }
  }
  
  if (pbmodcomp){
    if (!LRT) {
      stop('LRT needs to be set to TRUE as pbmodcomp uses its models')
    } else {}
    #Bootstrap p-values using PBmodcomp for effects .. REMEMBER TO INCREASE ITERATIONS
    boot.Cond <- PBmodcomp(xd.lmer, xd.lmer.2, nsim=10)
    boot.Meas <- PBmodcomp(xd.lmer, xd.lmer.3, nsim=10)
    boot.Int <- PBmodcomp(xd.lmer, xd.lmer.4, nsim=10)
      
    PBtest.Cond <- summary(boot.Cond)$test[1,4]
    Bartlett.Cond <- summary(boot.Cond)$test[3,4]
    Gamma.Cond <- summary(boot.Cond)$test[2,4]
    PBtest.Meas <- summary(boot.Meas)$test[1,4]
    Bartlett.Meas <- summary(boot.Meas)$test[3,4]
    Gamma.Meas <- summary(boot.Meas)$test[2,4]
    PBtest.Int <- summary(boot.Int)$test[1,4]
    Bartlett.Int <- summary(boot.Int)$test[3,4]
    Gamma.Int <- summary(boot.Int)$test[2,4]
    v1 <- c(v1, PBtest.Cond=PBtest.Cond, Bartlett.Cond=Bartlett.Cond, Gamma.Cond=Gamma.Cond,
            PBtest.Meas=PBtest.Meas, Bartlett.Meas=Bartlett.Meas, Gamma.Meas=Gamma.Meas,
            PBtest.Int=PBtest.Int, Bartlett.Int=Bartlett.Int, Gamma.Int=Gamma.Int)
    } else {}
    
  return(v1)
  
}